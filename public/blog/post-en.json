[
    {
        "badge": "article",
        "slug": "nest-vs-spring",
        "title": "Nest.js vs Spring: Backend Framework Comparison",
        "introduction": "Backend development offers a wide variety of frameworks to create robust, scalable, and efficient web applications. Two of the most prominent options are Nest.js and Spring. In this article, we will explore their differences and similarities in key aspects such as architecture, ecosystem, language, ease of use and performance",
        "sections": [
            {
                "slugTitle": "architecture",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "Architecture"
                    },
                    {
                        "type": "paragraph",
                        "text": "The architecture of a framework defines how applications are structured and organized, which significantly impacts scalability, maintainability, and flexibility. Choosing the right architectural approach is crucial to meet the specific needs of your application."
                    }
                ],
                "subsections": [
                    {
                        "slugTitle": "spring-framework",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Spring Framework"
                            },
                            {
                                "type": "paragraph",
                                "text": "Spring is a mature and versatile framework based on patterns like MVC (Model-View-Controller). Its core is the Inversion of Control (IoC) container, which manages the dependencies of applications. It provides flexibility to build both monolithic applications and microservices-based applications, thanks to tools like Spring Boot, which simplifies initial configuration."
                            }
                        ]
                    },
                    {
                        "slugTitle": "nestjs",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Nest.js"
                            },
                            {
                                "type": "paragraph",
                                "text": "Nest.js adopts a modular architecture inspired by Angular, where decorators and classes play a key role. This modular approach makes it easy to organize code into independent modules, which is ideal for scalable and microservices-based projects. Compared to other modern frameworks like Express or Fastify, Nest.js stands out for offering a clearer and more robust structure, reducing configuration effort and enabling more organized development from the start. It also includes native support for dependency injection patterns."
                            }
                        ]
                    },
                    {
                        "slugTitle": "comparison",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Comparison"
                            },
                            {
                                "type": "list",
                                "items": [
                                    "Nest.js offers a more modern and modular design from the start.",
                                    "Spring is more mature and flexible, allowing both traditional and modern architectures."
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "slugTitle": "ecosystem-spring",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "Spring Ecosystem"
                    },
                    {
                        "type": "paragraph",
                        "text": "The Spring ecosystem is vast and proven, with tools like:"
                    },
                    {
                        "type": "list",
                        "items": [
                            "Spring Boot: Simplifies configuration and deployment of applications.",
                            "Spring Data: Facilitates interaction with databases.",
                            "Spring Security: Provides a robust system for authentication and authorization management.",
                            "Spring Web: Offers a complete set of tools to develop web applications."
                        ]
                    },
                    {
                        "type": "paragraph",
                        "text": "Its community is one of the largest in the backend development world, offering commercial support and extensive documentation."
                    }
                ]
            },
            {
                "slugTitle": "ecosystem-nest",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "Nest.js Ecosystem"
                    },
                    {
                        "type": "paragraph",
                        "text": "Although younger, Nest.js has a rapidly growing ecosystem. It offers modern integrations for:"
                    },
                    {
                        "type": "list",
                        "items": [
                            "Databases: TypeORM, Prisma, Mongoose.",
                            "Advanced APIs: GraphQL, WebSockets.",
                            "Microservices: Tools to create and manage distributed services."
                        ]
                    },
                    {
                        "type": "paragraph",
                        "text": "Nest.js' community is active and constantly expanding, though it does not yet match the size of Spring's community."
                    }
                ]
            },
            {
                "slugTitle": "languages-java-vs-typescript",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "Programming Language: Java vs TypeScript"
                    },
                    {
                        "type": "paragraph",
                        "text": "Spring is based on **Java**, a robust and widely used language in enterprise environments. It is also compatible with other languages like Kotlin and Groovy, offering some flexibility."
                    },
                    {
                        "type": "paragraph",
                        "text": "Nest.js is written in **TypeScript**, a superset of **JavaScript** with static typing. This makes it particularly attractive for developers coming from the frontend or those looking for a modern language for agile projects."
                    }
                ],
                "subsections": [
                    {
                        "slugTitle": "java-or-typescript",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Comparison: Java or TypeScript"
                            },
                            {
                                "type": "list",
                                "items": [
                                    "Java excels in critical enterprise applications, offering a solid foundation for large-scale, long-term projects.",
                                    "TypeScript presents itself as the modern option for agile teams that prefer to work with frontend technologies and want to leverage static typing to improve code quality and productivity."
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "slugTitle": "ease-of-use",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "Ease of Use"
                    },
                    {
                        "type": "paragraph",
                        "text": "Spring has a steep learning curve due to its flexibility and power. However, Spring Boot significantly simplifies the initial configuration, enabling the creation of production-ready applications in no time."
                    },
                    {
                        "type": "paragraph",
                        "text": "Nest.js is more intuitive and beginner-friendly, especially for those familiar with TypeScript. Its modular structure and code generators make development easier."
                    }
                ]
            },
            {
                "slugTitle": "performance",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "Performance"
                    },
                    {
                        "type": "paragraph",
                        "text": "Performance is a critical factor in backend development and should be evaluated in terms of CPU consumption, memory usage, and the overall impact on development costs."
                    }
                ],
                "subsections": [
                    {
                        "slugTitle": "cpu-performance",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "CPU"
                            },
                            {
                                "type": "list",
                                "items": [
                                    "Nest.js: Built on Node.js, it uses a single-threaded event loop model. This makes it highly efficient for I/O-intensive applications. Some benchmarks show up to 20% less CPU usage in such cases compared to multi-threaded models.",
                                    "Spring Framework: Built on Java, it uses a multi-threaded model. This makes it more efficient for CPU-intensive tasks, offering up to 30% better performance in such scenarios."
                                ]
                            }
                        ]
                    },
                    {
                        "slugTitle": "memory-performance",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Memory"
                            },
                            {
                                "type": "list",
                                "items": [
                                    "Nest.js: Thanks to its modular and minimalist design, it can reduce memory usage by up to 40% in applications similar to those built in Spring Framework.",
                                    "Spring Framework: Consumes more memory due to its wide set of features. A typical enterprise application may require 200â€“300 MB more memory than its equivalent in Nest.js."
                                ]
                            }
                        ]
                    },
                    {
                        "slugTitle": "development-costs",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Development Costs"
                            },
                            {
                                "type": "list",
                                "items": [
                                    "Nest.js: Its base in JavaScript, a language known by 67.7% of developers, can shorten the learning curve and reduce development costs if the team is already proficient in JavaScript.",
                                    "Spring Framework: It may require specialized knowledge of Java, which could increase training costs if the team lacks prior experience."
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "slugTitle": "conclusion",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "Conclusions"
                    },
                    {
                        "type": "paragraph",
                        "text": "How to choose between Nest.js and Spring Framework? It largely depends on the specific needs of your project and the experience of your development team."
                    },
                    {
                        "type": "list",
                        "items": [
                            "Nest.js, based on modern JavaScript, is an accessible option for teams already proficient in JavaScript. Its leaner architecture and potentially lower memory footprint may result in reduced resource consumption and faster development times. Additionally, its single-threaded event loop model is perfect for I/O-intensive applications.",
                            "On the other hand, Spring Framework stands out for its robust feature set and multi-threaded model, ideal for more complex and CPU-intensive tasks. While memory usage may be higher and development costs may be higher for Java, the wide functionality Spring offers is a worthwhile trade-off for certain projects."
                        ]
                    },
                    {
                        "type": "paragraph",
                        "text": "The key to choosing between these frameworks is to fully understand the project requirements and carefully evaluate the pros and cons of each. With this information, you can ensure the success of your project."
                    }
                ]
            }
        ],
        "date": "December 29, 2024",
        "relatedSlug": "post-2"
    },
    {
        "badge": "article",
        "slug": "working-with-react-useeffect-hook",
        "title": "Rendering and Re-Rendering in React",
        "introduction": "In this article, you will learn what happens behind a 're-render' in React, what causes them, how to avoid them, and patterns to consider for optimizing our applications.",
        "sections": [
            {
                "slugTitle": "rendering-introduction",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "Introduction"
                    },
                    {
                        "type": "paragraph",
                        "text": "Understanding the key concepts of a library is essential to feel comfortable working with it. That's why I decided to write this article about the cornerstone that gave rise to React: 'renders'. Although React has evolved significantly in recent months, its essence remains intact: creating component-based interfaces that return JSX."
                    },
                    {
                        "type": "paragraph",
                        "text": "Mastering the process of 'rendering' and the events that trigger it is crucial for designing efficient applications and building a solid foundation for continued improvement. At the end of the day, working with React always leads us to discuss 'renders', so why not understand them thoroughly from the start?"
                    }
                ]
            },
            {
                "slugTitle": "what-is-a-render-in-react",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "What is a 'Render' in React"
                    },
                    {
                        "type": "paragraph",
                        "text": "Let's start by understanding what 'render' means in React. Essentially, a 'render' is the process by which React sends the JSX returned by a component to the DOM. This JSX is calculated from three key elements:"
                    },
                    {
                        "type": "list",
                        "items": [
                            "The properties (props) that the component receives.",
                            "The component's internal state.",
                            "The values of the contexts that the component consumes through the Context API."
                        ]
                    },
                    {
                        "type": "paragraph",
                        "text": "A component is rendered whenever it is part of the component tree we have defined."
                    },
                    {
                        "type": "image",
                        "src": "https://res.cloudinary.com/dhu8pktj2/image/upload/v1733336511/blog/render%20and%20rerender/tmo1gem70yyqaffag77k.png",
                        "alt": "Component Tree"
                    },
                    {
                        "type": "paragraph",
                        "text": "When the browser loads our application for the first time, React generates a component tree. Each component returns pieces of JSX that, when combined, define the complete structure of the interface. However, this structure is not static. As the user interacts with the application, the component tree can change in various ways:"
                    },
                    {
                        "type": "list",
                        "items": [
                            "Adding new components.",
                            "Removing existing components.",
                            "Modifying the state or props of already present components."
                        ]
                    },
                    {
                        "type": "paragraph",
                        "text": "The key moment in this process is the 'initial render', which occurs when a component first appears in the tree. During this first render, the component sets the initial values of its state.\n\nFrom there, we enter the realm of 'rerenders', where things get really interesting."
                    }
                ]
            },
            {
                "slugTitle": "what-is-a-re-render",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "What are 'Re-renders'"
                    },
                    {
                        "type": "paragraph",
                        "text": "A 're-render' is any rendering of a component that is already in the DOM and does not correspond to the 'initial render'."
                    },
                    {
                        "type": "paragraph",
                        "text": "Re-renders occur when there is a change in the application state, caused by:"
                    },
                    {
                        "type": "list",
                        "items": [
                            "User actions, such as interacting with an element of the interface.",
                            "External updates, such as the arrival of data from an API via a fetch call."
                        ]
                    }
                ],
                "subsections": [
                    {
                        "slugTitle": "when-is-a-re-render",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Types of 'Re-renders'"
                            },
                            {
                                "type": "paragraph",
                                "text": "We can classify re-renders into two main categories:"
                            },
                            {
                                "type": "list",
                                "items": [
                                    "Necessary re-renders: These are renders where the component is directly affected by a change, and its new JSX will differ from the previous one. Example: In a counter, when the user presses the button to increment it, the component needs a new render to display the updated value.",
                                    "Unnecessary re-renders: These occur when a component re-renders even if it has not been affected by the change and generates the same JSX as in the previous render."
                                ]
                            },
                            {
                                "type": "paragraph",
                                "text": "Common cause: An inefficient structure or poor planning of our application."
                            },
                            {
                                "type": "paragraph",
                                "text": "Unnecessary re-renders can affect the performance of the application, so identifying and avoiding them is key to maintaining a smooth user experience."
                            }
                        ]
                    }
                ]
            },
            {
                "slugTitle": "why-does-a-component-re-render",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "Reasons a Component Re-renders"
                    },
                    {
                        "type": "paragraph",
                        "text": "A component can re-render for one of the following reasons:"
                    },
                    {
                        "type": "list",
                        "items": [
                            "Change in internal state (declared using useState), usually as a result of a user action, such as clicking a button.",
                            "Change in context, if the component is consuming a context and its value is updated.",
                            "Re-render of the parent component, which causes, by default, all child components to re-render."
                        ]
                    },
                    {
                        "type": "paragraph",
                        "text": "Let's take a closer look at these:"
                    }
                ],
                "subsections": [
                    {
                        "slugTitle": "changes-in-state",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Changes in State"
                            },
                            {
                                "type": "paragraph",
                                "text": "When we declare a piece of state within a component using the useState hook, any change in that state, triggered by invoking setState, will cause a re-render of the component."
                            },
                            {
                                "type": "code",
                                "language": "javascript",
                                "code": "export const Counter = () => {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n};"
                            },
                            {
                                "type": "note",
                                "text": "Each time the state is updated with setCount, the component is rendered again."
                            }
                        ]
                    },
                    {
                        "slugTitle": "changes-in-context",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Change in Context"
                            },
                            {
                                "type": "paragraph",
                                "text": "When the value of a context changes, all components that are consuming that context via the useContext hook will re-render to ensure the view reflects the update."
                            },
                            {
                                "type": "code",
                                "language": "javascript",
                                "code": "const ContContext = createContext(0);\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <ContContext.Provider value={count}> \n      <Counter /> \n    </ContContext.Provider>\n  );\n}; \n"
                            },
                            {
                                "type": "note",
                                "text": "When the count state changes, the context in the Provider receives a new value. As a result, all components using useContext(ContContext) detect this change and automatically re-render."
                            }
                        ]
                    },
                    {
                        "slugTitle": "rendering-the-parent-component",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Re-rendering the Parent Component"
                            },
                            {
                                "type": "paragraph",
                                "text": "By default, a child component will re-render whenever its parent component does. In other words, when a component re-renders, all of its child components also re-render, even if there are no direct changes to them."
                            },
                            {
                                "type": "code",
                                "language": "javascript",
                                "code": "function App() {\n  return (\n    <div>\n      <Component /> \n    </div>\n  );\n}\n\nfunction Component() {\n ... \n}\n"
                            },
                            {
                                "type": "note",
                                "text": "In this case, the Component component re-renders every time the App component does."
                            }
                        ]
                    }
                ]
            },
            {
                "slugTitle": "how-to-prevent-unnecessary-re-renders",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "How to Prevent Unnecessary Re-renders"
                    },
                    {
                        "type": "paragraph",
                        "text": "Now that we know the reasons a component can render, let's explore some techniques that will help us prevent unnecessary re-renders and optimize the performance of our applications."
                    }
                ],
                "subsections": [
                    {
                        "slugTitle": "place-state-at-the-bottom",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Place State as Low as Possible"
                            },
                            {
                                "type": "paragraph",
                                "text": "This technique is useful when working with complex components that manage multiple states, especially if some of them are only used in specific parts of the component tree."
                            },
                            {
                                "type": "image",
                                "src": "https://res.cloudinary.com/dhu8pktj2/image/upload/v1733499382/blog/render%20and%20rerender/gbarvy0hgjckm8iuv7mo.png",
                                "alt": "Component Tree with State"
                            },
                            {
                                "type": "paragraph",
                                "text": "For example, if stateFour is only relevant for ComponentFour, keeping it at a higher level will cause any change in this state to trigger a render of the entire tree (remember: rendering a parent component also re-renders all its children). This can be inefficient."
                            },
                            {
                                "type": "paragraph",
                                "text": "To avoid this issue, we can define stateFour directly in ComponentFour, limiting its impact and ensuring changes only affect the component that truly needs it."
                            },
                            {
                                "type": "image",
                                "src": "https://res.cloudinary.com/dhu8pktj2/image/upload/v1733499408/blog/render%20and%20rerender/u2wjqegjlv0n7sk6axeu.png",
                                "alt": "Component Tree with Modified State"
                            }
                        ]
                    },
                    {
                        "slugTitle": "pass-components-as-props",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Pass Components as Props"
                            },
                            {
                                "type": "paragraph",
                                "text": "This technique is especially useful when working with expensive-to-render components that are contained within a component that renders frequently, such as a form managing inputs."
                            },
                            {
                                "type": "code",
                                "language": "javascript",
                                "code": "const FormComponent = () => {\n  // Component logic and state\n\n  return (\n    <div>\n      <input type=\"text\" placeholder=\"Input 1\" />\n      <input type=\"text\" placeholder=\"Input 2\" />\n      <SlowComponent />\n    </div>\n  );\n};"
                            },
                            {
                                "type": "paragraph",
                                "text": "Every time FormComponent renders, the inputs and SlowComponent also re-render, which can negatively affect performance."
                            },
                            {
                                "type": "paragraph",
                                "text": "To avoid this problem, we can pass the expensive component as a prop, for example, using children. This works because children is just a reference to the component, and React does not re-render it unless it explicitly changes. It's as if the component is already 'pre-rendered'."
                            },
                            {
                                "type": "code",
                                "language": "javascript",
                                "code": "const ParentComponent = () => {\n  return (\n    <FormComponent>\n      <SlowComponent />\n    </FormComponent>\n  );\n};\n\nconst FormComponent = ({ children }) => {\n  return (\n    <div>\n      <input type=\"text\" placeholder=\"Input 1\" />\n      <input type=\"text\" placeholder=\"Input 2\" />\n      {children}\n    </div>\n  );\n};"
                            },
                            {
                                "type": "paragraph",
                                "text": "This technique, known as 'wrapping state around children', is very useful for optimizing similar cases."
                            },
                            {
                                "type": "note",
                                "text": "This approach is not limited to the children prop: we can define any number of props in a component and use this pattern to prevent unnecessary renders."
                            }
                        ]
                    },
                    {
                        "slugTitle": "avoid-creating-components-inside-others",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Avoid Creating Components Inside Others"
                            },
                            {
                                "type": "paragraph",
                                "text": "It is important to avoid an anti-pattern that can cause significant performance issues: defining a component inside another."
                            },
                            {
                                "type": "code",
                                "language": "javascript",
                                "code": "function SomeComponent() {\n    const OtherComponent = () => {\n        const [state, setState] = useState();\n        useEffect(() => {\n            // Effect logic\n        }, []);\n\n        return <div>Component content</div>;\n    };\n\n    return (\n        <div>\n            <OtherComponent />\n        </div>\n    );\n}"
                            },
                            {
                                "type": "paragraph",
                                "text": "This code includes the OtherComponent component defined inside SomeComponent, which is an anti-pattern in React because it causes OtherComponent to re-mount and execute all its effects every time SomeComponent renders. This can be inefficient and lead to performance problems."
                            }
                        ]
                    }
                ]
            },
            {
                "slugTitle": "memoize-components-with-react-memo",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "Memoize components with React.memo"
                    },
                    {
                        "type": "paragraph",
                        "text": "React's memo function allows us to optimize functional components by wrapping them to avoid unnecessary renders. If the component's props haven't changed since the previous render, React reuses the previous result, improving performance. For those who have worked with class components, memo behaves similarly to the shouldComponentUpdate function, which allowed you to decide if a component should update. Let's see how to use memo with some practical examples."
                    }
                ],
                "subsections": [
                    {
                        "slugTitle": "component-without-properties",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Component without properties"
                            },
                            {
                                "type": "paragraph",
                                "text": "In this case, the component we are wrapping with React.memo does not receive any props. As a result, this component will not re-render even when the parent component renders, as it doesn't depend on external data."
                            },
                            {
                                "type": "paragraph",
                                "text": "This makes the optimization even simpler, as we don't need to check if the props have changed since there are no props to check."
                            },
                            {
                                "type": "code",
                                "language": "javascript",
                                "code": "const NoPropsComponent = React.memo(() => {\n    console.log('Rendering NoPropsComponent');\n    return <div>This component has no props</div>;\n});\n\nconst ParentComponent = () => {\n    const [count, setCount] = useState(0);\n\n    return (\n        <div>\n            <button onClick={() => setCount(prevCount => prevCount + 1)}>Increment</button>\n            <NoPropsComponent />\n        </div>\n    );\n};"
                            },
                            {
                                "type": "note",
                                "text": "In this example, every time ParentComponent renders (e.g., when count is incremented), NoPropsComponent does not re-render since it has no props and its rendering does not depend on any change in the parent component's state."
                            }
                        ]
                    },
                    {
                        "slugTitle": "component-with-props",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Component with properties"
                            },
                            {
                                "type": "paragraph",
                                "text": "When a memoized component with React.memo receives props, it will only re-render if one of those props changes. If the props don't change between renders, React will avoid unnecessary re-renders, which can improve performance."
                            },
                            {
                                "type": "code",
                                "language": "javascript",
                                "code": "const ExpensiveComponent = React.memo(({ value }) => {\n    console.log('Rendering ExpensiveComponent');\n    return <div>The value is: {value}</div>;\n});\n\nconst ParentComponent = () => {\n    const [count, setCount] = useState(0);\n    const [value, setValue] = useState('initial value');\n\n    return (\n        <div>\n            <button onClick={() => setCount(prevCount => prevCount + 1)}>Increment</button>\n            <button onClick={() => setValue(prevValue => prevValue === 'initial value' ? 'new value' : 'initial value')}>Change value</button>\n            <ExpensiveComponent value={value} />\n        </div>\n    );\n};"
                            },
                            {
                                "type": "note",
                                "text": "In this example, ExpensiveComponent will only re-render if the value of `value` changes. Even if the `count` state in ParentComponent changes (when the first button is clicked), ExpensiveComponent will not re-render if `value` does not change."
                            }
                        ]
                    },
                    {
                        "slugTitle": "combine-usememo-usecallback-with-memo",
                        "content": [
                            {
                                "type": "heading",
                                "level": 3,
                                "text": "Combine useMemo / useCallback with memo"
                            },
                            {
                                "type": "paragraph",
                                "text": "In React, `memo` is a powerful tool to avoid unnecessary renders of a component, but what happens when the component's props are functions, objects, or arrays? In these cases, `memo` won't work as expected unless we use the appropriate hooks. Let's see how we can improve this."
                            },
                            {
                                "type": "paragraph",
                                "text": "When we pass functions or objects as props to a memoized component, if those values change on every render, memoization won't take effect. This is because React treats the new functions or objects as different values, even if the content is the same. Let's see this in some examples."
                            },
                            {
                                "type": "code",
                                "language": "javascript",
                                "code": "import { memo } from 'react';\n\nconst Child = ({ onClick }) => <button onClick={onClick}>Click me</button>;\n\nconst MemorizedChild = memo(Child);\n\nconst Parent = () => {\n    const handleClick = () => console.log('Clicked!');\n\n    return (\n        <div>\n            <MemorizedChild onClick={handleClick} />\n        </div>\n    );\n};"
                            },
                            {
                                "type": "paragraph",
                                "text": "In this example, the `Parent` component creates a new `handleClick` function on every render. Although the function logic is the same, React creates a new reference every time, which causes `MemorizedChild` to receive a new value for `onClick` and re-render unnecessarily."
                            },
                            {
                                "type": "paragraph",
                                "text": "Another common case is when we pass an object as a prop. Let's see the following example."
                            },
                            {
                                "type": "code",
                                "language": "javascript",
                                "code": "import { memo } from 'react';\n\nconst Child = ({ pet }) => <div>{pet.name}</div>;\n\nconst MemorizedChild = memo(Child);\n\nconst Parent = () => {\n    const pet = { name: 'Fido' };\n\n    return (\n        <div>\n            <MemorizedChild pet={pet} />\n        </div>\n    );\n};"
                            },
                            {
                                "type": "paragraph",
                                "text": "In this case, `Parent` creates a new `pet` object on every render. Although the object's content doesn't change, its reference does, causing `MemorizedChild` to receive a new object on every render and re-render unnecessarily."
                            },
                            {
                                "type": "paragraph",
                                "text": "Fortunately, React provides the `useMemo` and `useCallback` hooks to prevent creating new instances of objects and functions on every render. Let's see how we can improve these examples."
                            },
                            {
                                "type": "paragraph",
                                "text": "The `useMemo` hook memoizes a calculated value between renders and only recalculates it if its dependencies change. It takes two parameters:"
                            },
                            {
                                "type": "list",
                                "items": [
                                    "1. A function that returns the value to be memoized.",
                                    "2. An array of dependencies, similar to the `useEffect` hook. The function will only execute if the dependencies change."
                                ]
                            },
                            {
                                "type": "paragraph",
                                "text": "On the other hand, `useCallback` memoizes functions in the same way. It takes two parameters:"
                            },
                            {
                                "type": "list",
                                "items": [
                                    "1. The function to be memoized.",
                                    "2. An array of dependencies. If any of the dependencies change, the function is recalculated; otherwise, the same instance is reused."
                                ]
                            },
                            {
                                "type": "code",
                                "language": "javascript",
                                "code": "import { useMemo, useCallback } from 'react';\n\nconst ParentComponent = ({ name }) => {\n    const pet = useMemo(() => ({ name }), [name]);\n\n    const logName = useCallback(() => {\n        console.log(name);\n    }, [name]);\n\n    return (\n        <div>\n            ...\n        </div>\n    );\n};"
                            },
                            {
                                "type": "paragraph",
                                "text": "With this, the previous examples can be improved to avoid unnecessary renders. Let's see how to apply `useMemo` and `useCallback` to improve the examples."
                            },
                            {
                                "type": "paragraph",
                                "text": "For the `onClick` function case, we can memoize it with `useCallback`, ensuring that its reference never changes between renders."
                            },
                            {
                                "type": "code",
                                "language": "javascript",
                                "code": "import { memo, useCallback } from 'react';\n\nconst Child = ({ onClick }) => <button onClick={onClick}>Press</button>;\n\nconst MemorizedChild = memo(Child);\n\nconst Parent = () => {\n    const handleClick = useCallback(() => {\n        console.log('Clicked');\n    }, []);\n\n    return (\n        <MemorizedChild onClick={handleClick} />\n    );\n};"
                            },
                            {
                                "type": "paragraph",
                                "text": "Now, even if `Parent` re-renders, `handleClick` will not be recreated because `useCallback` memoizes the function."
                            }
                        ]
                    }
                ]
            },
            {
                "slugTitle": "conclusion",
                "content": [
                    {
                        "type": "heading",
                        "level": 2,
                        "text": "Conclusions"
                    },
                    {
                        "type": "paragraph",
                        "text": "With this article, we have covered various React techniques to avoid unnecessary renders, which can significantly improve the performance of your applications."
                    },
                    {
                        "type": "paragraph",
                        "text": "My advice is to first familiarize yourself with the different causes that can trigger a re-render and learn to identify which components are susceptible to optimization. With the approaches I have explained, you will be able to make your application more efficient while also gaining a better understanding of how React's rendering system works."
                    },
                    {
                        "type": "paragraph",
                        "text": "Mastering these techniques will not only allow you to write more efficient code but also deepen your understanding of how React handles UI updates and rendering, which is key to building fast, high-performance applications."
                    }
                ]
            }
        ],
        "date": "November 6, 2024",
        "relatedSlug": "post-1"
    }
]